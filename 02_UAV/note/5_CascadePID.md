多旋翼（quad）在飞控里常用两套坐标：

- **NED 坐标（惯性/导航系）**：
  (x) 指北、(y) 指东、(z) 指**下**（Down 为正）。所以重力向量通常写成
  $$
  g^n = [0,0,g]^T
  $$

- **Body 坐标（机体系）**：绑在飞机上，随飞机一起转。常用定义：($x_b$) 机头前、($y_b$) 机体右、($z_b$) **向下**。

系统“状态”你要控制的是：

- 位置 ($p$)（在 NED）
- 速度 ($v$)（在 NED）
- 姿态 ($R$)（把 body 向量转到 NED 的旋转矩阵：($R_b^n$)
- 角速度 ($\omega$)（通常在 body）

你真正能下的“底层按钮”是电机转速 ($\omega_i$)（每个电机），它产生：

- 总推力 ($T$)
- 三轴力矩 ($\tau = [\tau_x,\tau_y,\tau_z]^T$)

------

# 串级结构：每一环到底在“输出什么命令”

- **位置环**：$(p \to v_{des})$
- **速度环**：$(v \to a_{des})$（含重力补偿/限幅）
- **姿态环**：$(R_{des} \to \omega_{des})$
- **角速度环**：$(\omega \to \tau)$
- **分配/电机**：$([T,\tau_x,\tau_y,\tau_z] \to \omega_i \to) 实际 (T,\tau)$

## 1.1 位置环（“导航司机”）

- 输入：位置误差
  $$
  e_p = p_{des}-p
  $$

- 输出：期望速度
  $$
  e_p = p_{des}-p
  $$

- 再做速度限幅：
  $$
  |v_{des}|\le v_{max}
  $$

**直觉**：离目标远 → 希望跑快点；靠近目标 → 自动收油减速。**它不直接管推力/姿态**，只管“你应该以多快的速度去”。

------

## 1.2 速度环（“油门与刹车的驾驶员”）

- 输入：速度误差
  $$
  e_v = v_{des}-v
  $$

- 输出：期望惯性加速度（在 NED）
  $$
  a_{des} = a_{ff} + K_{p,v}e_v + K_{i,v}\int e_v + K_{d,v}\dot e_v
  $$

- 再做加速度限幅：
  $$
  |a_{des}|\le a_{max}
  $$

**直觉**：你现在比目标速度慢很多 → 给更大的“加速意图”；反之给“减速意图”。
注意：这里的 ($a_{des}$) 还是**世界系(NED)** 的“我想怎么加速”，它还没变成“该怎么倾斜机身 + 给多少推力”。

------

## 1.3 核心难点：($a_{des} \to (R_{des}, T_{des})$)

这一步就是把“世界里想怎么加速”变成“机身该朝哪儿倾 + 推力给多少”。你给的动力学（忽略阻力）是：

- 机体推力在 body：
  $$
  f_b = [0,0,-T]^T
  $$
  （因为 ($z_b$) 向下，推力实际是“沿 ($-z_b$)”）

- 转到 NED：
  $$
  F_T^n = R_b^n f_b = -Tb_3^n
  $$
  其中 ($b_3^n$) 是 ($R_b^n$) 第三列：**机体 ($z_b$) 轴在 NED 里的方向**。旋转矩阵的列向量，物理意义上正是 原坐标系的基向量（轴）在 新坐标系下的投影。

  假设我们有一个旋转矩阵 $R_b^n$（把 Body 坐标系转换到 NED 坐标系）。我们要找的是：Body 坐标系的 Z 轴，在 NED 坐标系里长什么样？在 Body 坐标系自己看自己的时候，Z 轴向量是非常简单的单位向量：
  $$
  z_{body} = \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
  $$
  （因为它在 X 方向是 0，Y 方向是 0，完全就在 Z 轴上，长度为 1）。现在，我们想知道这个向量在 NED 坐标系里是多少（即 $z_{ned}$），根据旋转矩阵的定义：
  $$
  z_{ned} = R_b^n \times z_{body}
  $$

  $$
  R_b^n = \begin{bmatrix}  r_{11} & r_{12} & \color{red}{r_{13}} \\ r_{21} & r_{22} & \color{red}{r_{23}} \\ r_{31} & r_{32} & \color{red}{r_{33}} \end{bmatrix}
  $$

  $$
  z_{ned} = \begin{bmatrix}  r_{11} & r_{12} & \color{red}{r_{13}} \\ r_{21} & r_{22} & \color{red}{r_{23}} \\ r_{31} & r_{32} & \color{red}{r_{33}} \end{bmatrix}  \times  \begin{bmatrix} 0 \\ 0 \\ \mathbf{1} \end{bmatrix}
  $$

  $$
  z_{ned} = \begin{bmatrix} \color{red}{r_{13}} \\ \color{red}{r_{23}} \\ \color{red}{r_{33}} \end{bmatrix}
  $$

  **发现了吗？结果正好就是旋转矩阵的第三列！**对于旋转矩阵 $R_b^n$：

  - **第一列**：是 Body 坐标系的 **X 轴**（$[1, 0, 0]^T$）在 NED 坐标系里的样子。
  - **第二列**：是 Body 坐标系的 **Y 轴**（$[0, 1, 0]^T$）在 NED 坐标系里的样子。
  - **第三列**：是 Body 坐标系的 **Z 轴**（$[0, 0, 1]^T$）在 NED 坐标系里的样子。

- 平动加速度：
  $$
  a^n = \dot v^n = g^n + \frac{1}{m}F_T^n
  = g^n - \frac{T}{m}b_3^n
  $$

你希望 ($a^n = a_{des}$)，所以：
$$
-\frac{T}{m}b_3^n = a_{des}-g^n
$$
定义一个“需要推力来提供的加速度向量”：
$$
u \triangleq a_{des}-g^n
$$

- $a_{des}$：是你**想要**的加速度。
- $-g^n$：是为了**抵消重力**。因为重力一直在把你往下拉，你想悬停或移动，首先得产生一个力去抵消重力。

所以，$u$ 本质上代表了无人机为了达到目标运动，总共需要产生的“合加速度”矢量。乘以质量 $m$ 后，$F_{total} = m u$ 就是无人机需要产生的总合力。

那么：
$$
b_{3,des}^n = -\frac{u}{|u|},\qquad
T_{des} = m|u|
$$
四旋翼无人机是一个**欠驱动系统**，想象你背着一个喷气背包（这就是无人机）：

1. **限制：** 你的喷气背包喷口是固定的，只能沿着你的脊椎方向（$b_3$轴）喷气。你不能横着喷，也不能斜着喷。
2. **任务：** 现在的计算结果 $u$ 告诉你：“你需要往**右上角45度**的方向施力”。
3. **操作：** 既然你只能顺着脊椎喷气，为了往右上角用力，你唯一的办法就是**把身体歪过来**，让你的脊椎（$b_3$）精确地指向那个力的方向。

 $b_{3,des}^n = -\frac{u}{\|u\|}$ 是在做**方向对齐**。

- **$u$**：是“需要的力的矢量”（包含大小和方向，比如 $(3, 4, 10)$）。
- **$\|u\|$**：是这个矢量的长度（模长）。
- **$\frac{u}{\|u\|}$**：这步叫**归一化（Normalization）**。它去掉了力的大小信息，只保留了**方向**。这就变成了一个长度为1的单位矢量，纯粹代表“那边”。
- **$b_{3,des}$**：这是无人机机身坐标系的 Z 轴（通常垂直于机身平面）。
- 为什么有负号（$-$）？这取决于坐标系的定义。
  - 在很多航空惯例（如 NED 坐标系）中，$b_3$ 轴是指向**机身下方**的。
  - 但是，螺旋桨产生的升力是推向**机身上方**的（或者说为了往上飞，喷气向下，反作用力向上）。
  - 所以，如果 $u$ 指向天空，推力就要指向天空，但机身的 $b_3$ 轴是指向地面的。方向相反，所以需要一个**负号**。

 $T_{des} = m \|u\|$？解决了方向，接下来要解决**力度**。

- **$m$**：无人机的质量。
- **$\|u\|$**：刚才计算出的“合加速度”的大小。
- **$T_{des}$**：期望的推力。

根据牛顿第二定律 $F=ma$：既然我们已经把机身旋转好了，现在只需要让螺旋桨转得足够快，产生足够大的推力即可。这个推力的大小，自然就等于**质量 × 想要的总加速度大小。**

**这两句的物理意义**：

- ($u$) 是“除了重力之外，你还想要的净加速度”，推力必须去实现它；
- 推力方向在 NED 里是 ($-b_3$)，所以 ($b_3$) 要指向 ($-u$) 的方向；
- 推力大小就等于“需要的净加速度大小 × 质量”。

------

## 1.4 给定期望 yaw，把 ($b_3$) 补成完整 ($R_{des}$)

因为仅靠 ($b_3$) 只确定了“机体竖直轴朝哪”，还缺“机头朝哪”（yaw）。

1. 用期望偏航 ($\psi_{des}$) 定义一个“水平机头参考方向”（NED）：这里的并不是最终的$b_{2,c}^n$,并不是旋转矩阵的第二列，注意有下标$c$,代表的是中间的，合成的。
   $$
   b^n_{L,c} = \begin{bmatrix}
   \cos\psi_{des} \\
   \sin\psi_{des} \\
   0
   \end{bmatrix}
   $$
   它就是“希望机头在水平面指向哪里”。无人机是一个 4 自由度的系统（$x, y, z, yaw$）。

   - **$b_3$（推力方向）**：负责搞定 $x, y, z$ 的位移。它决定了飞机往哪飞、飞多快。
   - **Yaw（偏航角）**：负责搞定**“脸朝哪看”**。

   例子：假设你要向正北飞 100 米。

   - **方案 A**：机头朝北，往前飞（正常飞）。
   - **方案 B**：机头朝东，往左侧飞（横着飞）。
   - **方案 C**：机头朝南，倒着飞。

   在这三种方案中，$b_3$（推力方向）是完全一样的（都是为了把飞机往北推）。但是！机身的姿态（旋转矩阵）是完全不同的。$\psi_{des}$ 就是用来区分你是想“正着飞”、“横着飞”还是“倒着飞”的。

2. 用叉乘做正交基：
   $$
   b_{2,des}^n = \frac{b_{3,des}^n \times b_{1,c}^n}{||b_{3,des}^n \times b_{1,c}^n||},\qquad
   b_{1,des}^n = b_{2,des}^n \times b_{3,des}^n
   $$
   旋转矩阵 $R$ 需要三个互相垂直的轴（$b_1, b_2, b_3$）。

   - **第一块拼图（最重要）：** $b_3$。这是物理死命令！如果 $b_3$ 不对，飞机就会飞歪或者掉下来。所以我们**必须优先保证 $b_3$ 是我们要的那个推力方向**。
   - **第二块拼图（次要）：** $\psi_{des}$。这是为了好看或者任务需求。

3. 拼成旋转矩阵（列向量就是 body 轴在 NED 的方向）：
   $$
   R_{des} =
   \begin{bmatrix}
   b_{1,des}^n & b_{2,des}^n & b_{3,des}^n
   \end{bmatrix}
   $$

- ($b_3$)：机身“竖直轴”必须对准推力需求；
- ($b_{1,c}$)：你希望机头大概朝向；
- 叉乘就是“把它们拉成互相垂直的一组轴”。

合法的旋转矩阵（Rotation Matrix），它的三列必须、绝对、一定互相垂直（正交），而且每列的长度必须是 1。在数学上，旋转矩阵属于 **特殊正交群 (Special Orthogonal Group)**，记作 **$SO(3)$**。要成为 $SO(3)$ 的会员，必须同时满足三个苛刻条件：

1. **正交性 (Orthogonality)**：
   - $b_1, b_2, b_3$ 三个轴必须两两垂直（夹角 90 度）。
   - 也就是：$b_1 \cdot b_2 = 0$，$b_2 \cdot b_3 = 0$ ...
2. **单位长 (Normality)**：
   - $b_1, b_2, b_3$ 的长度必须都等于 1。不能拉伸，不能缩短。
   - 也就是：$\|b_1\| = 1$。
3. **右手定则 (Right-Hand Rule / Determinant = +1)**：
   - 这一条最容易被忽略。三根手指必须符合右手定则结构。
   - 如果你把 $X$ 轴镜像反转一下，虽然它还满足前两条，但它变成了左手系（行列式 = -1）。这对物理世界是灾难。

想象一个刚性的、不变形的立方体盒子。旋转矩阵就是描述这个盒子怎么转。

- 如果你把盒子压扁了（不正交），那就不是旋转。
- 如果你把盒子拉长了（长度不为1），那就不是旋转。
- 如果你把盒子翻面了（镜像），那就不是旋转。

当 ($b_{3,des}^n$) 恰好和 ($b_{1,c}^n$) 平行/反平行时，叉乘接近 0，会炸。工程处理：

- 若 ($||b_3\times b_{1,c}|| < \epsilon$)，就换一个参考方向，比如用 ($[1,0,0]^T$) 或 ($[0,1,0]^T$) 作为临时 ($b_{1,c}$)。

------

## 1.5 姿态环：($R_{des} \to \omega_{des}$)（输出“该怎么转”）

姿态环不直接输出力矩，它输出一个“期望角速度”，交给更快的角速度环去实现。

1. 相对旋转（在 body 表达）：
   $$
   R_{err} = R^T R_{des}
   $$
   它表示“从当前姿态转到目标姿态，需要转多少”。为什么不能直接 $R_{des} - R$？

   - **线性世界（位置）：** 目标位置 10 米，当前位置 2 米。误差 = $10 - 2 = 8$ 米。这叫减法。

   - **旋转世界（姿态）：** 旋转矩阵不能做减法！两个矩阵相减出来的东西没有物理意义。

   - 旋转的“减法”是“乘法”：代表**“动作的叠加”**或者**“坐标系的转换”**

     在旋转里，“减去一个旋转”等于“乘以它的逆矩阵”。

     因为旋转矩阵是正交阵，逆矩阵 $R^{-1}$ 等于转置矩阵 $R^T$。

   - **$R$**：表示 **Body $\to$ World** （把机身翻译成世界）。
   - **$R^T$**：矩阵的转置。对于旋转矩阵，转置 = 逆矩阵 ($R^{-1}$)。所以 **$R^T$** 表示 **World $\to$ Body** （把世界翻译回机身）。

   按照从右向左的顺序（线性代数通常是从右往左运算向量）：
   $$
   \underbrace{R^T}_{\text{World} \to \text{Body}} \times \underbrace{R_{des}}_{\text{Target} \to \text{World}}
   $$
   想象一个向量 $v$ 经过这个流程：

   1. **第一步（$R_{des}$）**：先把 **目标姿态（Target）** 的向量翻译成 **世界（World）** 的。
   2. **第二步（$R^T$）**：再把 **世界（World）** 的向量翻译成 **当前机身（Body）** 的。

   中间的“World”被抵消了！结果是：Target $\to$ Body。“站在我现在机身（Body）的视角看，目标（Target）相对于我，歪了多少？”也即只看方向，不看大小。最右边乘了一个单位矩阵是最完全体，**Target 坐标系（目标系）的三根轴，在它自己眼里的样子就是单位矩阵**。
   $$
   R_{err} = R^T \times (R_{des} \times I_{des})
   $$
   
2. 用 Angle-Axis 得到旋转向量：
   $$
   e_R = \theta \hat u
   $$
   这就是你要的“**姿态误差向量**”：方向是旋转轴，长度是旋转角度（弧度）。什么要搞这一步？$R_{err}$ 不就是误差了吗？

   $R_{err}$ 是一个 $3 \times 3$ 的矩阵（9个数）。PID 控制器需要的是一个向量（比如“向左偏了5度”），而不是一个矩阵。我们需要把这 9 个数“压缩”成更直观的形式。

   物理原理：欧拉旋转定理，任何一个旋转（不管它看起来多复杂，先翻滚再偏航），都可以等效为：绕着空间中某一个轴（$\mathbf{u}$），转过某一个角度（$\theta$）。

   - **$\mathbf{u}$（旋转轴）：** 一根棍子，指明了转动的方向。
   - **$\theta$（角度）：** 绕着这根棍子转多少度。

   $e_R$ 是什么？

   我们把 $\theta$ 和 $\mathbf{u}$ 乘在一起：$e_R = \theta \cdot \mathbf{u}$。

   - **方向：** 这个向量指哪里，你就该绕着哪根轴转。
   - **长度：** 这个向量有多长，就代表你误差有多大（角度有多大）。

   从矩阵 $R_{err}$ 提取向量 $e_R$ 的公式（罗德里格斯公式的逆运算）是：
   $$
   e_R = \frac{1}{2} [R_{err} - R_{err}^T]^\vee
   $$
   （其中 $\vee$ 符号叫 vee map，就是把反对称矩阵变成向量）。

   > 你不需要去推导罗德里格斯公式（那是数学家的事）。
   >
   > 你只需要知道：这一步是为了把 9 个数的矩阵，变成 3 个数的向量。这个向量告诉我们：绕哪个轴转，转多少度。

3. 输出期望角速度（body）：
   $$
   \omega_{des} = K_{p,R} e_R
   $$
   再做限幅 $(|\omega_{des}|\le \omega_{max})$​。为什么乘个系数 $K_p$ 就变成角速度了？这是最简单的 P 控制（比例控制）。

   - **$e_R$**：角度误差（比如：差了 30度）。
   - **$K_{p,R}$**：增益（比如：2.0）。
   - **逻辑**：
     - 如果误差是 30度，我就命令角速度为 $30 \times 2 = 60$ 度/秒。
     - 如果误差只有 1度，我就命令角速度为 $1 \times 2 = 2$ 度/秒。
     - **离目标越远，跑得越快；离目标越近，慢慢停下。**

   > 这步的物理意义：把“空间上的角度差距”，转化成“时间上的速度指令”。

------

## 1.6 角速度环：($\omega \to \tau$)（真正“拧飞机”的那一环）

- 输入：角速度误差
  $$
  e_\omega = \omega_{des}-\omega
  $$

- 输出：力矩命令
  $$
  \tau_{cmd} = K_{p,\omega}e_\omega + K_{i,\omega}\int e_\omega + K_{d,\omega}\dot e_\omega
  $$

- 再按电机能力限幅$ (||\tau||\le\tau_{max})$

**直觉**：姿态环说“你应该以这么快角速度转过去”；角速度环负责“立刻打多大力矩让你达到这个角速度”。

------

## 1.7 分配/电机：($[T,\tau]\to \omega_i$)

这是把总推力/力矩转换成每个电机转速。你只需要先掌握两点：

- 有一个固定的“混控矩阵”把 ($\omega_i^2$) 映射到 ($[T,\tau]$)
- 需要处理**饱和**（某个电机打满）与**优先级**（一般保姿态 > 保高度）

------

# “外慢内快 5–10 倍”

把内环看成外环的“执行器”。外环以为它下了命令，内环会立刻跟上。如果内环不够快，会发生两件坏事：

1. **相位滞后变大 → 相位裕度下降 → 容易振荡**
   外环给一个指令（比如要更大倾角），内环慢半拍才做到；外环看到误差没变小，又继续加指令；等内环终于跟上时，外环已经“加过头”了，于是来回摆。
2. **耦合变强、调参变玄学**
   位置/速度环会“看见”姿态没跟上，于是把误差归咎到自己，疯狂加输出；姿态又在追；最后系统像多人抢方向盘。

> 外环的变化频率如果接近内环闭环带宽，内环就不再像“理想跟随器”，外环等于在驱动一个带延迟的系统，相位裕度掉得很厉害。
> 保持 5–10 倍分离，外环眼里内环≈瞬时完成，耦合小、调参直观。

工程上常见的频率层级（给你一个“合理数量级”）

- 电机/ESC：几百 Hz～kHz（很快）
- 角速度环（rate）：200–500 Hz
- 姿态环（attitude）：50–100 Hz
- 速度环：20–50 Hz
- 位置环：5–10 Hz

------

## 把整条链路串起来

你可以把飞控主循环想成“从外到内一路下命令”：

- (慢) 位置环:  $p -> v_{des}$
- (中) 速度环:  $v -> a_{des}$  (限幅)
- (中) 几何映射: $a_{des} -> (b^3_{des}, T_{des}) -> R_{des} $(用 yaw)
- (快) 姿态环:  $R, R_{des} -> \omega_{des} $(限幅)
- (更快) 角速度环: $\omega, \omega_{des} -> \tau_{cmd} $(限幅+抗饱和)
- (更快) 分配: $[T_{des}, \tau_{cmd}] $-> motor speeds -> 实际推力力矩

------

# 工程实现

## 低通滤波

求导（Derivative）的几何意义是斜率。
$$
\text{斜率} = \frac{\text{高度差}}{\text{时间差}} = \frac{\Delta y}{\Delta t}
$$

- **理想信号：** 一条平滑的曲线。斜率（导数）也是平滑变化的。
- **现实信号（噪声）：** 真正的传感器数据看起来像是一条平滑曲线上长满了“锯齿”。这些锯齿就是**高频噪声**。

假设你的 IMU 传感器有一点点微小的震动（噪声），幅度只有 0.01（非常小）。但是，这个震动发生得极快，比如在 0.001秒（1毫秒）内这就发生了一次跳变。我们算算 D 项会输出什么：
$$
\text{噪声导致的 D 输出} = K_d \times \frac{\text{变化量}}{\text{时间间隔}} = K_d \times \frac{0.01}{0.001} = K_d \times 10
$$
**输入只有 0.01 的微小抖动，经过求导（除以极小的 dt），瞬间被放大了 1000 倍！**

1. **高频放大**：你以为你在计算信号的变化率，其实你在计算噪声的剧烈跳动。
2. **电锯声**：D 项输出忽大忽小（比如 +100, -100, +100），电流疯狂冲击电机，电机就会发出像电锯一样的“滋滋”声。
3. **发热**：电机并没有真的转起来（因为切换太快，惯性跟不上），能量全部变成了热量。

> 你要掌握的结论：纯粹的微分项 $s$ 在物理上是无法实现的，也是危险的。所有的 D 项，在工程中必须配合低通滤波器使用。

------

### 脏微分

“脏微分”（Dirty Derivative）这个名字听起来不雅，但它是工业界的标准做法。学名叫做**“带低通滤波的微分器”**。它的核心思想是：**既然噪声是高频的（跳得快），那我就把高频成分切掉，只对剩下的低频信号（真实运动）求导。**这里涉及到一个核心算法：**一阶低通滤波器（Low Pass Filter, LPF）**。
$$
e_f[k] = \alpha e_f[k-1] + (1-\alpha)e[k]
$$

- **$e[k]$**：当前的测量值（比如现在的误差，带噪声，最新的数据）。
- **$e_f[k-1]$**：上一次计算出来的、已经平滑过的值（历史的积淀）。
- **$e_f[k]$**：我们要算的当前平滑值。
- **$\alpha$ (Alpha)**：**滤波系数**（0 到 1 之间）。

**写法 A：先滤波，再求导**

1. 拿到带噪声的误差 $e[k]$。
2. 用 $\alpha$ 公式把它变成平滑的 $e_f[k]$。
3. 再用平滑后的值做差分：$\text{导数} = (e_f[k] - e_f[k-1]) / dt$。

- **通俗理解**：先把路面的坑填平（滤波），再去测量路的坡度（求导）。

**写法 B：直接计算“平滑的导数”**

这是你在飞控源码（如 PX4, ArduPilot）里最常看到的写法。
$$
\dot{e}_f[k] = \beta \dot{e}_f[k-1] + (1-\beta) \frac{e[k] - e[k-1]}{dt}
$$

1. 先算出一个“原始的、带噪声的导数”：$\frac{e[k] - e[k-1]}{dt}$。
2. 然后把**这个导数**放进滤波公式里去平滑。

- **通俗理解**：不管路面平不平，先算现在的坡度（虽然很抖），然后把这次算的坡度和上次算的坡度平均一下。

> 小白怎么学？你不需要去推导 $\alpha$ 和截止频率 $f_c$ 的关系（虽然公式是 $\alpha = \frac{RC}{RC+dt}$）。
>
> 你只需要记住：代码里一定会有个 $\alpha$ 或 $\beta$，调大它，噪声变小，但控制会变迟钝；调小它，反应变快，但电机可能会响。这是一个博弈。

---

### 推导过程

在物理学或模拟电路中，一个标准的**一阶低通滤波器（RC电路）**的微分方程是这样的：
$$
\tau \frac{dy(t)}{dt} + y(t) = x(t)
$$

- $x(t)$: 输入信号（含噪声）
- $y(t)$: 滤波后的输出
- $\tau$: 时间常数
- $\frac{dy}{dt}$: 输出的变化率

**这个方程的物理含义是：** 输出值 $y$ 想跟着输入 $x$ 变，但是被 $\tau$ 拖了后腿（惯性），变化率 $\frac{dy}{dt}$ 被限制了。为什么有了 $\tau \frac{dy}{dt}$ 这一项，高频信号就过不去了？

我们把方程改写一下，看看**输出的变化率**（速度）由什么决定：
$$
\frac{dy}{dt} = \frac{x(t) - y(t)}{\tau}
$$

- **$x(t) - y(t)$**：**差距**（目标在哪 - 我在哪）。
- **$\frac{1}{\tau}$**：**加速倍率**（$\tau$ 越小，倍率越大，你是对的）。
- **$\frac{dy}{dt}$**：**追赶速度**。

所以公式就是：
$$
\text{追赶速度} = \text{差距} \times \text{加速倍率}
$$
有了速度，$y$ 到底能走多远？这取决于每一步的时间 ($dt$)：
$$
y_{\text{下一步的位置}} = y_{\text{当前}} + (\text{追赶速度} \times \text{持续时间 } dt)
$$
假设 $\tau = 0.03$ 秒（加速倍率 $\approx 33$）。

- **低频状态**：输入 $x$ 变成了 1，并且**一直保持**在那里，给了 $y$ 整整 1 秒钟去追。
- **第 0.01 秒时**：
  - 差距 = $1 - 0 = 1$
  - 速度 = $1 / 0.03 \approx 33.3$ （速度确实很快！）
  - **关键点**：这个状态持续了很久。
- **结果**：
  - 虽然每一瞬间 $y$ 只能走一点点，但因为 $x$ **站在那里没动**，$y$ 有无数个 $dt$ 可以累积。

**结论**：只要给足时间，积分效应会让 $y$ 最终等于 $x$。

假设这个噪声是一个**极其短暂的高频脉冲**：

- $t=0$ 时，$x=0$。
- $t=0.001$ 时，$x$ 突然变成 **100**。
- $t=0.002$ 时，$x$ 立刻变回 **0**。
- (整个过程只有 0.001 秒)。

**在 $t=0.001$ 秒这一刻**：

- 差距 = $100 - 0 = 100$。
- **追赶速度** = $\frac{100}{0.03} = \mathbf{3333.3}$。

- 这个疯狂的速度，只能持续 **0.001 秒**（因为下一毫秒 $x$ 就没了）。
- **实际走的距离** = 速度 $\times$ 时间
- $\text{距离} = 3333.3 \times 0.001 = \mathbf{3.33}$

- 目标 $x$ 要求 $y$ 跑到 **100** 的位置。$y$ 拼了老命，速度飙到了 3333，但因为只有 0.001 秒的时间，它拼死拼活只跑到了 **3.33**。下一瞬间，$x$ 消失了（变回0），$y$ 又得跑回来。

目标让你去 100，你只到了 3。这就叫被滤除了。

---

电脑是不懂“微分” ($\frac{dy}{dt}$) 的，电脑只懂“每一步的差值”。我们需要把微分方程变成差分方程。我们使用最常用的 **后向欧拉法 (Backward Euler)** 来近似微分：
$$
\frac{dy}{dt} \approx \frac{y_k - y_{k-1}}{dt}
$$

- $y_k$: 当前时刻的输出
- $y_{k-1}$: 上一时刻的输出
- $dt$: 你的代码循环时间（比如 0.01s）

把上面的近似公式代入物理方程：
$$
\tau \left( \frac{y_k - y_{k-1}}{dt} \right) + y_k = x_k
$$
现在我们的目标是算出 $y_k$（当前输出），所以我们要解这个方程：
$$
\tau (y_k - y_{k-1}) + dt \cdot y_k = dt \cdot x_k\\
(\tau + dt) y_k = dt \cdot x_k + \tau y_{k-1}\\
y_k = \left( \frac{dt}{\tau + dt} \right) x_k + \left( \frac{\tau}{\tau + dt} \right) y_{k-1}
$$
如果我们定义一个系数 $\alpha$：高频噪声实际上就是短暂变换的，这中短暂导致了$y$他追不上$x$，但是$\tau$还控制着速度，$\tau$大的时候他的速度相对于$\tau$小的时候慢，但是时间是相同的，因此他追的距离更短。

- 也即$\tau$越大，截止频率越低，系统越迟顿，滤波越强。
- 也即$\tau$越小，截止频率越高，系统越灵敏，滤波越弱。

$$
\alpha = \frac{dt}{\tau + dt}\\
1 - \alpha = 1 - \frac{dt}{\tau + dt} = \frac{\tau + dt - dt}{\tau + dt} = \frac{\tau}{\tau + dt}
$$

得到:
$$
y_k = \alpha \cdot x_k + (1 - \alpha) \cdot y_{k-1}
$$

------

## 为什么 D 项适合角速度环？

这里涉及到了**传感器特性**和**控制层级**。

### 为什么角速度环（内环）敢用 D？

1. **数据源好**：角速度环的数据来自**陀螺仪（Gyro）**。它是 MEMS 芯片，直接测量旋转速率。虽然有噪声，但它的刷新率极高（1000Hz - 8000Hz），而且噪声通常是高斯白噪声，很容易用上面的滤波器滤除。
2. **物理延迟小**：陀螺仪直接反映机身动态，中间没有复杂的计算过程，数据非常“鲜活”。
3. **D 的需求大**：四旋翼非常灵活，这就意味着它也很不稳。我们需要强有力的 D（阻尼）来抑制震荡，让飞机像是在粘稠的蜂蜜里飞，而不是在真空里乱晃。

### 为什么位置环/速度环（外环）尽量不用 D？

1. **数据源“脏”**：位置和速度通常来自 **GPS**、**气压计** 或 **视觉里程计**。
   - GPS 只有 10Hz（很慢）。
   - GPS 的噪声不是随机的，会有漂移。
   - 如果你要从位置求导得到速度，再求导得到加速度（D项），这个过程就是**对垃圾数据求两次导**，结果基本不能用。
2. **延迟大**：GPS 数据到达飞控本身就有几十毫秒的延迟。对外环再加 D（D 项滤波会引入额外延迟），系统可能会相位滞后太多，导致发散。

这部分内容是 GNC 工程师必须刻在脑子里的“安全守则”。你现在的角色就像是一个负责安全的建筑师，虽然理论上大楼可以建一千层，但现实中风会吹倒它，地基会塌陷。

**限幅（Saturation/Limiting）的本质就是：承认物理世界的局限性，并保护你的飞机不要因为数学公式的“贪婪”而炸机。**

下面我为你逐一拆解这些限幅的物理含义和操作逻辑。

------

## 限幅：“防 NaN / 防硬撞 / 防失控”

> 你的控制器算出来的东西可能超出物理能力或安全边界。你必须在每个层级把它裁剪到“可实现、可安全”的范围内。

### 3.1 速度限幅 $\|v_{des}\| \le v_{max}$

- $\|v_{des}\|$：期望速度向量的长度（模长），即总速率。
- $v_{max}$：你设定的最大飞行速度（比如 10米/秒）。

想象你的位置控制是一个 P 控制器（$v = K_p \times \text{误差}$）。

- **场景：** 你的目标点在 1公里 以外。
- **如果不限幅：** 误差 = 1000米。$v_{des} = 1.0 \times 1000 = 1000 \text{m/s}$（超音速！）。
- **多米诺骨牌效应：**
  1. 速度环看到“我要飞 1000m/s”，它会计算出一个**巨大的加速度**去追这个速度。
  2. 巨大的加速度 $\rightarrow$ 要求飞机**倾斜 90度**（垂直立起来飞）。
  3. 飞机实际上做不到，于是积分项（I项）发现误差一直不消除，开始疯狂积累（Windup），最后导致**飞控发散，飞机乱飞**。

我们不能简单地把 $x, y, z$ 三个分量分别切断（那样会改变飞行方向）。我们要**保持方向不变，把箭头缩短**。

#### **向量缩放**

:若 $||v_{des}\||>v_{max}$，则：
$$
v_{des} \leftarrow v_{des}\cdot \frac{v_{max}}{\|v_{des}\|}
$$
保方向不变，只缩大小，其实就是向量归一化乘以个最大值。

------

### 3.2 加速度限幅 $\|a_{des}\| \le a_{max}$

- $a_{des}$：期望加速度（速度环的输出）。

由牛顿第二定律 $F=ma$，**限制加速度就是在限制受力**。

对于四旋翼：

- **水平加速度**：靠**倾斜**产生。加速度越大 $\rightarrow$ 倾角越大。
- **垂直加速度**：靠**总推力**产生。加速度越大 $\rightarrow$ 电机负荷越大。

如果 $a_{des}$ 过大，意味着你要求飞机瞬间从 0 加速到 100km/h，这需要电机瞬间输出几倍于自身能力的推力，或者机身瞬间翻转。这物理上不可能，会导致**执行器饱和（Actuator Saturation）**，控制系统失效。和速度限幅一模一样：向量缩放。

------

### 3.3 倾角限幅 $\theta_{tilt} \le \theta_{max}$（重中之重）

四旋翼的推力 $T$ 只有一个方向：垂直机身向上。

当你倾斜机身去飞的时候，推力被分解成了两部分：

1. **水平分量**：推着你跑。
2. **垂直分量**：抵消重力，让你不掉下来。

倾角 $\theta$ 越大，垂直分量 $F_{vertical} = T \times \cos(\theta)$ 就越小。

- 如果你倾斜了 60度，$\cos(60^{\circ}) = 0.5$。这意味着你需要 **2倍的总推力** 才能保持高度。
- 如果你倾斜了 85度，$\cos(85^{\circ}) \approx 0.08$。这意味着你需要 **12倍的总推力** 才能不掉下来。电机根本做不到！

**后果：** 飞机猛地加速冲出去，但是**高度像石头一样往下掉**。

#### **圆锥限制**

我们在计算出 $u$（期望推力向量）之后，必须检查它和竖直方向（$[0,0,1]$）的夹角。

如果夹角超过了 45度（比如 $\theta_{max} = 45^{\circ}$）：我们要把 $u$ 强行投影回一个 45度的圆锥里。假设有期望推力向量 $u = [u_x, u_y, u_z]$ 。

我们要把它拆解成两个分量来看：

1. 垂直分量（Height）：它决定了能不能抗住重力。
   $$
   h = u_z
   $$

2. 水平分量（Radius）：它决定了飞机倾斜的方向和程度。
   $$
   r = \sqrt{u_x^2 + u_y^2}
   $$

这就构成了一个直角三角形：

- **直角边1**：高度 $h$（垂直方向）。
- **直角边2**：半径 $r$（水平方向）。
- **斜边**：向量总长 $\|u\|$。
- **夹角 $\theta$**：就是我们要限制的倾角。

**圆锥限制**的核心逻辑是：**对于当前这个高度 $h$，水平半径 $r$ 不能无限大。**你可以想象一个倒立的圆锥，只要 $h$ 确定了，在这个高度下，圆锥面的半径 $r_{max}$ 也就确定了。

根据三角函数（正切 $\tan$）：
$$
r_{max} = h \times \tan(\theta_{max})
$$

- 如果你的 $r \le r_{max}$：说明向量在圆锥肚子里，**安全**，不用动。
- 如果你的 $r > r_{max}$：说明向量捅破了圆锥面，跑出去了，**危险**，需要限制。

当发现 $r > r_{max}$ 时，我们必须要把这根“出墙”的向量拉回来。

**原则：**

1. **保高度（关键）：** 我们绝对不能乱动 $u_z$（高度 $h$）。如果为了限制倾角把 $u_z$ 改小了，飞机就会掉高度炸机。所以 $h$ 保持不变。
2. **保方向：** 飞机想往“东北”飞，你限制完之后还得是“东北”，不能变成“正北”。所以水平向量的方向不能变。
3. **压大小：** 唯一能做的，就是把**水平分量 $r$ 缩短**，缩到刚好等于 $r_{max}$。

1. 计算当前的水平长度：
   $$
   r_{current} = \sqrt{u_x^2 + u_y^2}
   $$

2. 计算允许的最大水平长度：
   $$
   r_{allowed} = u_z \times \tan(\theta_{max})
   $$

3. 计算缩放系数（Scale Factor）：
   $$
   k = \frac{r_{allowed}}{r_{current}}<1
   $$

4. 执行缩放（只缩放水平部分）：
   $$
   u_{x, new} = u_x \times k\\
   u_{y, new} = u_y \times k\\
   u_{z, new} = u_z \quad (\text{保持不变！})
   $$

这样，新的向量 $u_{new}$ 就完美地贴在了圆锥的边缘上。

> **GNC 工程师黑话：** 这叫“Feasible Region Constraint”（可行域约束）。保证你的命令在物理上是玩得转的。

------

### 3.4 角速度限幅 $\|\omega_{des}\| \le \omega_{max}$

姿态环（P控制）输出期望角速度。

- 如果姿态误差是 180度（飞机翻过来了）。
- $P$ 控制器会喊：“以 1000度/秒 的速度转回去！”

为什么不行？电机也是有惯性的，桨叶是有空气阻力的。电机不可能瞬间让飞机达到这么高的转速。如果给出的指令超出了物理响应能力，飞机就会像喝醉了一样震荡。

依然是向量缩放。限制 $\omega$ 通常设为 3~6 rad/s（约 150~300度/秒）。这已经是非常快的特技飞行速度了。

------

### 3.5 力矩限幅 $|\tau| \le \tau_{max}$

飞机转弯靠的是电机转速不一样（差动）。

- 左边电机快，右边电机慢 $\rightarrow$ 向右滚。
- 但是，电机转速是有上限的！

如果需要的力矩太大，意味着：

- 电机 1 需要 120% 的转速。

- 电机 2 需要 -20% 的转速。

  这显然不可能。

#### 逐轴截断

> **速度/加速度** 是为了走**“轨迹”**。如果你把分量切坏了，飞机就**走歪了**（去错地方了）。
>
> **力矩（Roll/Pitch/Yaw）** 是三个独立的**“通道”**。如果你把某个分量切坏了，只是那个轴**转得慢一点**，并不会干扰别的轴正常工作。

也即对轴某个轴进行截断。你可能会问：“反正最后都要看电机行不行，为什么要在第一阶段（力矩）就先切一刀？”

这是因为 **“轴（Roll/Pitch/Yaw）”** 和 **“电机（M1/M2/M3/M4）”** 的关系是 **“一对多”** 的耦合关系。

1. **力矩限幅（逐轴截断）保护的是“逻辑”**

假设 PID 算出来 Roll 需要 10000 的力矩（因为误差极大）。

- 如果不在这里把 Roll 切断（Clipping），这个巨大的数字进入混控矩阵计算：
  - $M1 = 10000 + \dots$
  - $M2 = -10000 + \dots$
- 这就导致算出来的电机转速全是 **NaN（无效值）** 或者巨大的 **负数**。
- **后果**：混控器直接算崩了，后面的电机策略根本没法处理。
- **所以：** 必须在力矩层面（$\tau$）先切一刀，保证进混控器的数字是“人类能理解的数字”。

2. **这里的“逐轴”是指 XYZ 轴，不是电机轴**

当我们说“力矩逐轴截断”时：

- 指的是：**Roll 轴（X轴）** 太大了，切 Roll。
- **完全不影响 Pitch 轴（Y轴）**。
- **而不是** 指“1号电机太快了切1号”。

------

### 3.6 电机转速限幅 $\omega_{min} \le \omega_i \le \omega_{max}$

这是最后一道防线，直接作用在硬件指令上。

#### 上限 $\omega_{max}$

- **物理保护**：防止电机过热、防止桨叶射出去、防止电池过流保护。

#### 下限 $\omega_{min}$（怠速）——这个很多小白不懂

你会问：“为什么不能是 0？停转不行吗？”

- **气动稳定性**：螺旋桨如果停转，重新启动需要时间（从静摩擦到动摩擦），这会造成巨大的**控制延迟**。
- **控制线性度**：螺旋桨在转速很低的时候，产生的推力和转速的关系非常不准（模型失效）。
- **倒栽葱**：如果在空中停转某个电机，飞机瞬间就会失去平衡翻滚，再想救回来就难了。

**所以：** 我们通常会给一个“怠速（Idle Speed）”，比如 5%~10% 的油门。只要飞机解锁（Armed），电机就必须以这个最低速度旋转，**绝对不能停**。

------

### 总结你的“安全架构”

想象数据流经过这些关卡：

1. **位置环**算出速度 $\to$ **关卡1：速度限幅**（别超音速）
2. **速度环**算出加速度 $\to$ **关卡2：加速度限幅**（别太猛）$\to$ **关卡3：倾角限幅**（别掉高）
3. **姿态环**算出角速度 $\to$ **关卡4：角速度限幅**（别转晕）
4. **角速度环**算出力矩 $\to$ **关卡5：力矩限幅**（别超负荷）
5. **混控器**算出电机转速 $\to$ **关卡6：电机限幅**（别停转，别烧鸡）

每一道限幅都是为了让你的数学公式，向残酷的物理世界**低头妥协**。这就是工程。

### **为什么 Z 轴 (Yaw) 限幅较低？**

#### `tau_max` (力矩限幅)

```c++
Eigen::Vector3d tau_max = Eigen::Vector3d(1.0, 1.0, 0.5); // N*m per-axis
```

- **物理含义**：这是我们在前面讨论过的 **“力矩限幅（Stage 1）”**。它定义了电机能产生的最大旋转力矩。
  - **Roll (1.0)**：飞机左右翻滚的最大劲儿。
  - **Pitch (1.0)**：飞机前后俯仰的最大劲儿。
  - **Yaw (0.5)**：飞机机头转向的最大劲儿。

- 这是四旋翼的**物理特性**决定的。
- Roll/Pitch 靠的是左右/前后电机的**推力差**（力臂长，力气大）。
- Yaw 靠的是电机旋转的**反扭矩**（Reaction Torque）。这个力非常弱（效率很低）。即是转子旋转的时候会使得机体反向旋转的力矩。
- **工程经验**：Yaw 的能力通常只有 Roll/Pitch 的一半甚至更少。如果你把 Yaw 的限制设得和 Roll 一样大，PID 算出来的命令电机根本执行不了，会导致 Yaw 轴积分饱和（Windup），飞机就会在空中转圈失控。

#### `kp_att` (姿态 P 增益)

```C++
// Attitude P gain: omega_des = Kp_att * e_R
Eigen::Vector3d kp_att = Eigen::Vector3d(6.0, 6.0, 3.0);
```

- **物理含义**：这是 **“姿态环（Attitude Loop）”** 的控制参数。
  - 它负责把 **“角度误差（我歪了多少）”** 转化成 **“期望角速度（我要多快转回去）”**。
  - 公式：$\omega_{des} = k_p \times (R_{des} \ominus R_{curr})$。
- **数值解读**：
  - **6.0 (Roll/Pitch)**：这叫**刚度（Stiffness）**。数值越大，飞机回正越猛，反应越快。6.0 是一个比较中规中矩的值，如果是竞速机（穿越机），这个值可能高达 10.0~15.0。
  - **3.0 (Yaw)**：又是 Yaw。因为 Yaw 轴物理响应慢（力气小），如果你要求它像 Roll 一样快（设成 6.0），它跟不上，就会产生震荡。所以通常 Yaw 的增益会设得低一点，让它“慢慢转”。

## 前馈 (Feedforward)

**前馈（Feedforward）** 是一种**开环（Open-loop）**控制策略。它不依赖传感器的反馈（即不看误差），而是根据物理模型和目标轨迹，**提前计算**出系统此刻理论上需要的控制量，并直接叠加到 PID 的输出上。

- **一句话概括**：前馈是“基于知识的预判”，PID 是“基于误差的修正”。

------

### 为什么要引入前馈？

纯 PID 控制（只有反馈）存在天然的**滞后性（Lag）**：

1. **被动响应**：PID 必须等到**误差（Error）已经发生**之后，P、I、D 三项才会开始计算输出。
2. **跟踪性能差**：在高速机动或剧烈变化（如急转弯、猛加速）时，纯 PID 会导致飞机始终落后于目标点（Tracking Error 大）。

前馈的作用：在误差产生之前，就根据物理定律（如牛顿第二定律）给出一部分力，抵消系统的惯性或重力，实现**“零延迟”跟踪**。

------

### 前馈的数据来源与数学原理

前馈数据不是 PID 算出来的，而是由**轨迹规划器（Planner）通过对目标轨迹进行数学求导**得到的。

假设目标位置是关于时间的函数 $p_{des}(t)$：

1. **前馈速度 ($v_{ff}$)**：

   - **来源**：目标位置的一阶导数。

   - $$
     v_{ff} = \frac{d}{dt} p_{des}(t)
     $$

   - **作用**：告诉速度环，为了跟上这个位置变化，你现在的速度必须是多少。

2. **前馈加速度 ($a_{ff}$)**：

   - **来源**：目标位置的二阶导数（即目标速度的导数）。

   - $$
     a_{ff} = \frac{d^2}{dt^2} p_{des}(t)
     $$

   - **作用**：告诉内环（姿态/力矩），为了产生这个速度变化，你需要输出多大的力（$F=ma$）。

------

### 控制架构中的位置

前馈是**加法**关系，它不改变 PID 的内部参数，只是改变 PID 的基准点。

**速度环公式：**
$$
v_{des} = \underbrace{\text{PID}(p_{des} - p_{now})}_{\text{纠错项 (Feedback)}} + \underbrace{v_{ff}}_{\text{基准项 (Feedforward)}} \\
\mathbf{v}_{des} =  \underbrace{\mathbf{v}_{corr}}_{\text{反馈修正 (Feedback Correction)}}+\underbrace{\mathbf{v}_{ff}}_{\text{前馈 (Feedforward)}}
$$
**加速度环（或力矩）公式：**
$$
a_{des} = \underbrace{\text{PID}(v_{cmd} - v_{now})}_{\text{纠错项 (Feedback)}} + \underbrace{a_{ff}}_{\text{基准项 (Feedforward)}} \\\mathbf{a}_{des} =  \underbrace{\mathbf{a}_{corr}}_{\text{反馈修正 (Feedback Correction)}}+\underbrace{\mathbf{a}_{ff}}_{\text{前馈 (Feedforward)}}
$$

- **场景**：开车上一个陡坡。
- **纯 PID (新手司机)**：
  - 脚放在油门上不动 $\rightarrow$ 车开始上坡 $\rightarrow$ 速度掉下来了（产生误差） $\rightarrow$ 发现不对劲，深踩油门补救。
  - **结果**：上坡初期会明显减速，甚至溜车。
- **PID + 前馈 (老司机)**：
  - 眼睛看到前面是坡（规划器预判） $\rightarrow$ 大脑计算出“上这个坡需要多踩20%油门”（前馈计算） $\rightarrow$ **在还没上坡时**，脚直接多踩 20% 油门。
  - **PID 的工作**：如果风阻太大，速度还是慢了一点点，PID 再微调补一点油门。
  - **结果**：如履平地，速度平稳。

在一个优秀的控制系统中，控制力的分配通常是这样的：

- **前馈 (Feedforward)**：承担 **80% - 90%** 的工作量。
  - 负责克服已知的物理限制（惯性、重力、阻尼）。
  - 负责让系统“跑出个大概”。
- **反馈 (PID Feedback)**：承担 **10% - 20%** 的工作量。
  - 负责消除外界干扰（风、气流）。
  - 负责修正模型不准带来的微小误差。
  - 负责把“大概”修整成“精确”。

### 冲突与一致性

#### **1. 什么是“冲突”？(The Conflict)**

想象你在指挥一个司机（控制器）：

- **命令 A (Position Loop)**：告诉司机“你现在应该在 **0米** 的位置”。
- **命令 B (Velocity Feedforward)**：告诉司机“你现在的速度应该是 **100米/秒**”。

**司机（控制器）就疯了：**

> “老板，你到底要我怎样？如果我保持 100米/秒（命令B），我下一秒就在 100米外了，不可能保持在 0米（命令A）啊！”

这就是 **Conflict**。

- **位置环**会试图把你拉回 $P_{des}$。

- 速度前馈会试图把你推向 $V_{ff}$。

  如果这两个数不符合微积分关系（$P \neq \int V dt$），控制器内部就会左右互搏，导致飞机动作抽搐、震荡或者超调。

#### 2. 什么是“一致性”？(The Consistency)

注释里的 **“Integrating to obtain...” (积分以获得...)** 就是解决办法。

为了不让司机发疯，你的命令必须符合物理定律：

- 如果你要求速度 $v = 1.0$ 米/秒。
- 那么在第 3 秒时，你的目标位置 **必须** 设为 $p = 3.0$ 米。

只有这样：

- 位置环看到：我现在在 3米，目标是 3米 $\rightarrow$ 误差为 0 $\rightarrow$ 不捣乱。
- 速度前馈看到：目标速度 1.0 $\rightarrow$ 直接给电机加油。
- **结果**：完美配合。

这就是注释的意思：**“既然我设定了速度 $v$，我就必须通过积分（$p=v \times t$）算出对应的位置 $p$，这样位置环和速度前馈才不会打架。”**